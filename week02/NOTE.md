# 本周总结

## 1. 产生式

产生式（BNF）是描述语言结构标准的一种方式，虽然 ES 标准不是用 BNF 写的，但是原理思想差不多，通过产生式，我们可以结构化、模块化、标准化的学习学习一门语言或者描述一门语言。

## 2. 阅读标准文档

通过产生式可以更方便快速的理解标准文档，参考文档中对 JS 的 String 和 Number 的定义写练习题，这样对语言本身的理解更加深刻，而且更加全面的了解这些知识，一定程度上体现了**通过文档学习更加全面**。

动手实践学来的知识更加稳固。

## 3. 一点经验

所有代码的第一行都是空行，防止一些系统读取文本时，先拿一个字符判断是大端还是小端
，造成被‘吃’一个字符的现象。

# 作业
## 1. 写一个正则表达式 匹配所有 Number 直接量

解题思路：

根据 `ECMA-262` `11.8.3` 标准来拆解分类

- 十进制

```
有符号整数
    +或- 十进制串                    [+-]?\d+

指数
    指数符 有符号整数                 [Ee][+-]?\d+

十进制数
    0123456798                      \d

非零十进制数
    123456789                       [1-9]

十进制串
                                    \d+

十进制整数
    0                               0 
    非零十进制数 十进制串           [1-9]\d*
    综合                            0|[1-9]\d*

十进制直接量
    十进制整数 . 十进制串 指数        (0|[1-9]\d*)[.](\d+)?([Ee][+-]?\d+)?
    . 十进制串 指数                  [.]\d+([Ee][+-]?\d+)?
    十进制整数 指数                  (0|[1-9]\d*)([Ee][+-]?\d+)?
    综合                            ((0|[1-9]\d*)[.](\d+)?|[.]\d+|(0|[1-9]\d*))([Ee][+-]?\d+)?

```

综上，匹配十进制的表达式为 `((0|[1-9]\d*)[.](\d+)?|[.]\d+|(0|[1-9]\d*))([Ee][+-]?\d+)?`

- 二进制
  ```
  二进制直接量
    0b或0B 二进制串                  0[Bb][01]+

  二进制数串
    二进制数                         [01]
    二进制数串 二进制                 [01]+

  二进制数
    0或1                            [01]

  ```
   综上，匹配二进制的表达式为 `0[Bb][01]+`

   同理，匹配八进制的表达式为 `0[Oo][0-7]+`

   匹配十六进制的表达式为 `0[Xx][0-9a-fA-F]+`

   合起来就是 `0(?:[Bb][01]+|[Oo][0-7]+|[Xx][0-9a-fA-F]+)`

综综上，加上正负号和开头结尾符，匹配所有数字的表达式就是 `^[+-]?(0([Bb][01]+|[Oo][0-7]+|[Xx][0-9a-fA-F]+)|((0|[1-9]\d*)[.](\d+)?|[.]\d+|(0|[1-9]\d*))([Ee][+-]?\d+)?)$`

### 不足
 - 不知道标准里为什么没写正负类型，这个正负是我加进去的，不知道对不对
 - 没有考虑老式八进制写法（0开头）
 - 没有使用非捕获括号 `(?:)` （这个功能是不是在这里用的）
    
### 收获
 - `JS` 中除了十进制都没有小数和指数的概念，以前不知道
 - 学习了正则表达式

## 2. 写一个 UTF-8 Encoding 的函数

```JS
function encode2UTF8(str) {
    const utf8Arr = [];
    for (let i of str) {
        let utf16Code = i.codePointAt(0);
        if (utf16Code >= 0x0000 && utf16Code <= 0x007F) {
            utf8Arr.push(utf16Code)
        } else if (utf16Code > 0x007F && utf16Code <= 0x07FF) {
            utf8Arr.push(0xC0 | (utf16Code >> 6));
            utf8Arr.push(0x80 | (0x003F & utf16Code));
        } else if (utf16Code > 0x07FF && utf16Code <= 0xFFFF) {
            utf8Arr.push(0xE0 | (utf16Code >> 12));
            utf8Arr.push(0x80 | (0x003F & (utf16Code >> 6)));
            utf8Arr.push(0x80 | (0x003F & utf16Code));
        } else if (utf16Code > 0xFFFF && utf16Code <= 0x1FFFFF) {
            utf8Arr.push(0xF8 | (utf16Code >> 18));
            utf8Arr.push(0x80 | (0x003F & (utf16Code >> 12)));
            utf8Arr.push(0x80 | (0x003F & (utf16Code >> 6)));
            utf8Arr.push(0x80 | (0x003F & utf16Code));
        }
    }
    return utf8Arr.map((i, v) => '0x' + i.toString(16)).join('');
}
```


## 3. 写一个正则表达式，匹配所有的字符串直接量，单引号和双引号

- 最简单的就是前后被单双引号包围的字符串 `(?<=").*(?=")`
- 根据标准文档，字符串中不能包含 `'` `\` `\u000a` `\u000d`，所以 `(?<=")[^\u000a\u000d\\"]*(?=")`
- 但是可以包含（\ 后面加）任何字符除了超出范围的十六进制转义序列和Unicode码点  `(?<=")(?:\\[^]|[^\u000a\u000d\\"])*(?=")`
- 去除不符合规则的Unicode码点和十六进制转义序列 `(?<=")(?:\\[^ux]|\\u[0-f]{4}|\\u{10[0-f]{4}}|\\x[0-f]{2}|[^\u000a\u000d\\"])*(?=")`
- 综上匹配所有字符串的正则为 `(?<=")(?:\\[^ux]|\\u[0-f]{4}|\\u{10[0-f]{4}}|\\x[0-f]{2}|[^\u000a\u000d\\"])*(?=")` 或 `(?<=')(?:\\[^ux]|\\u[0-f]{4}|\\u{10[0-f]{4}}|\\x[0-f]{2}|[^\u000a\u000d\\'])*(?=')`